# JPEG Compression Pipeline in Python

## Project Overview
This project implements a complete JPEG compression pipeline in Python without using any built-in functions except `cv2.imread` for image reading. The pipeline includes:
- **Color Space Conversion (RGB to YCbCr)**
- **Sub-sampling (optional)**
- **Discrete Cosine Transform (DCT)**
- **Quantization**
- **Run-length Encoding (RLE)**
- **Huffman Coding (optional)**

The goal is to reduce image size while preserving quality, leveraging various compression techniques as specified in the JPEG standard.


## Authors
- Allen Emmanuel Binny [21EC39035]

## Project Structure
- **report.pdf**: Detailed explanation of each step in the pipeline and the techniques used.
- **presentation.pptx**: Summarizes the project workflow, implementation steps, and results.
- **src/**: Contains all source code files.
- **results/**: Includes:
  - **input/**: Sample input images of various sizes and colors.
  - **output/**: Compressed image data files generated by the code and their respective compression ratios.

## Pipeline Implementation

### 1. Color Space Conversion
The image is first converted from **RGB to YCbCr** color space, where:
- **Y** represents luminance (brightness).
- **Cb** and **Cr** represent chrominance (color information).

### 2. Sub-sampling (Optional)
For further size reduction, we use **4:2:0 sub-sampling** on the Cb and Cr channels. This reduces the chroma resolution by half, preserving visual quality while saving data.

### 3. Discrete Cosine Transform (DCT)
Each color channel is divided into 8x8 blocks, and a **DCT** is applied to each block. This transforms the image data into frequency space, concentrating most of the image information into fewer coefficients.

### 4. Quantization
Using a standard **quantization matrix**, we reduce the precision of each DCT coefficient. This step is key for reducing file size by discarding less significant data, particularly in high-frequency regions.

### 5. Run-length Encoding (RLE)
The quantized DCT coefficients often contain long sequences of zeros. **RLE** compresses these sequences, further reducing the data.

### 6. Huffman Coding (Optional)
For optimal encoding, **Huffman coding** is applied to the RLE output. This step, while optional, increases the compression efficiency by encoding frequent symbols with shorter codes.

## Results
The following table summarizes the compression ratios achieved on different images:

| Image Name         | Original Size (KB) | Compressed Size (KB) | Compression Ratio |
|--------------------|--------------------|-----------------------|-------------------|
| example1.jpg       | 512                | 140                   | 3.66:1           |
| example2.jpg       | 1024               | 230                   | 4.45:1           |
| ...                | ...                | ...                   | ...              |

## Usage
1. Place the input images in the `results/input` folder.
2. Run the main script using:
   ```bash
   python src/compress_image.py
3. The compressed output files and their compression ratios will be stored in `results/output`.

## Dependencies
- Python 3.x
- OpenCV (for `cv2.imread`)

## References
- https://en.wikipedia.org/wiki/YCbCr - For RGB to YCbCr 